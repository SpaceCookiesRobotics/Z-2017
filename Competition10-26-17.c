#pragma config(Sensor, dgtl1,  bumper_foxunichicken, sensorTouch)
#pragma config(Sensor, dgtl2,  LED_blue,       sensorLEDtoVCC)
#pragma config(Motor,  port1,           Motor5,        tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           leftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           leftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           DoNotYouDare,  tmotorNone, openLoop)
#pragma config(Motor,  port7,           Motor7,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Motor8,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           Motor9,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          Motor6,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//#include  "Shared/Competition.h"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//#BUILTBYGIRLS

void drivestraight (int speed, int duration) {
	motor[rightFront] = speed;
	motor[leftFront] = speed;
	motor[rightBack] = speed;
	motor[leftBack] =  speed;
	wait1Msec(duration);
	motor[rightFront] = 0;
	motor[leftFront] = 0;
	motor[rightBack] = 0;
	motor[leftBack] = 0;
}

void driveside (int speed, int duration) {
	motor[rightFront] = speed;
	motor[leftFront] = -speed;
	motor[rightBack] = -speed;
	motor[leftBack] = speed;
	wait1Msec(duration);
	motor[rightFront] = 0;
	motor[leftFront] = 0;
	motor[rightBack] = 0;
	motor[leftBack] = 0;
}
void pointturn (int speed, int duration) {
	motor[rightFront] = speed;
	motor[leftFront] = -speed;
	motor[rightBack] = speed;
	motor[leftBack] = -speed;
	wait1Msec(duration);
	motor[rightFront] = 0;
	motor[leftFront] = 0;
	motor[rightBack] = 0;
	motor[leftBack] = 0;
}

// lift the eight bar
void lift (int speed, int duration) {
	motor[Motor5] = speed;
	motor[Motor6] = speed;
	motor[Motor8] = speed;
	motor[Motor9] = speed;
	wait1Msec(duration);
	motor[Motor5] = 0;
	motor[Motor6] = 0;
	motor[Motor8] = 0;
	motor[Motor9] = 0;
}
//opens and closes the claw. Antara's Idea. :)
void crab (int speed, int duration) {
	motor[Motor7] = speed;
	wait1Msec(duration);
}

void autonMobileGoal(){
	crab(-60,600);
	drivestraight(70, 1800);//drive forward
	crab(60,500);
	drivestraight(70,700);
	crab(-70, 1000);//close claw on mobile ghoul 0_0
	motor[Motor7] = -30;//keep claw closed
	lift(70,500);
	motor[Motor5] = 15;
	motor[Motor6] = 15;
	motor[Motor8] = 15;
	motor[Motor9] = 15;
	pointturn(70, 1500);
	drivestraight(70,2300);
	lift(-20,800);
	crab(70,500);




	////	autonStationary();
	//crab(-70,600); //close claw
	//drivestraight(70, 1000); //drive forward
	//pointturn(-70,450);//Turn right
	//drivestraight(70,1700);//Forwards
	//crab(60,200);
	//pointturn(70,800);//Turn Left
	//driveside(70,200);
	//drivestraight(70,400);
	//crab(-60, 1400);//Close claw on cone
	//motor[Motor7] = -15; //Keep claw closed on cone
	//drivestraight(-70,700); //back up

	//pointturn(70,800); //turn left LITTLE ANJALI IS THE BEST!
	//drivestraight(70,2000); //drive to stationary goal
	//lift(70,1200); //lift cone
	//motor[Motor6] = 20; //hold
	//motor[Motor5] = 20; //hold
	//pointturn(-70,560); //turn so cone is above stationary goal
	//drivestraight(-70,300);
	//lift(-10,300); //put cone on stationary goal
	//lift(10,0); //hold
	//crab(70,300);//let go of cone
	//drivestraight(-70,600); //back up
	//lift(-70,700); //put 8 bar down


	/*SECTION THREE, GRAB SECOND CONE
	drivestraight(-70, 500);//Backwards
	lift(70,1000);//Lift down
	driveside(70,1000);//Crabwalk right
	drivestraight(70, 500);//Forwards
	crab(-70, 500);//Close claw on cone
	motor[Motor7] = -5;//Keep claw closed on cone

	//SECTION 4, MOVE AND SCORE SECOND CONE(2 points)
	drivestraight(-70, 500);//Drive backwards
	driveside(-70, 800);//Crabwalk left
	lift(-70, 1500);//Lift up
	motor[Motor5] = -10;
	motor[Motor6] = -10;//Hold
	drivestraight(70,200);//Forwards just a little bit
	lift(70,300);//Lift down to place cone on stationary goal
	crab(70,500);//Open claw to drop on stationary

	//SECTION 5 AMANDA VER
	drivestraight(-70, 200); //Drive backwards just a bit
	driveside(70,400); //to the side just a bit
	drivestraight(70,800); //drive forward
	crab(-70,400); //grab the cone
	crab(-20,0); //hold
	drivestraight(-70, 900);//drive back
	driveside(-70,550); // drive in front of the goal
	lift(-70,1750); //lift to score
	drivestraight(70,200); //foward just a bit
	lift(70,200); //move the lift down
	crab(70, 400); //let go of the cone

	/*SECTION 5, GRAB THIRD CONE
	drivestraight(-70, 500);//Backwards
	lift(-70,1000);//Lift down
	driveside(70,1400);//Crabwalk right
	drivestraight(70, 400);//Forwards
	crab(70, 500);//Close claw on cone
	crab(20,0);//Keep claw closed on cone

	//SECTION 6, MOVE AND SCORE THIRD CONE (2 points)
	drivestraight(-70,500);//Backwards
	driveside (-70, 800);//Crabwalk left
	drivestraight (70,200);//Forward
	lift(70, 2500);//Lift up
	lift(20,0);//Hold
	drivestraight(70,200);//Forwards just a little bit
	lift(-70,300);//Lift down to place cone on stationary goal
	crab(-70,500);//Open claw to drop on stationary cone

	//SECTION 7, GRAB FOURTH CONE
	drivestraight(-70, 500);//Backwards
	lift(-70,1000);//Lift down
	driveside(70,1400);//Crabwalk right
	drivestraight(70, 400);//Forwards
	crab(70, 500);//Close claw on cone
	crab(20,0);//Keep claw closed on cone

	/*TOTAL POINTS
	first cone: 2 points
	second cone: 2 points
	third cone: 2 points
	*/
}

task main(){

	//void autonomous() {
	autonMobileGoal();

	//}




	//void joystick(){
	while(1 == 1){
		float ratio = 1.0;
		while (vexRT[Btn5U]){ ratio = 0.7;}
		while (vexRT[Btn5DXmtr2]){ ratio = 0.6;}
		if (SensorValue[bumper_foxunichicken] == 1) {

			motor[Motor5] = 0;
			motor[Motor6] = 0;
			motor[Motor8] = 0;
			motor[Motor9] = 0;
		}
		//Remote Control Commands
		motor[leftFront] = ratio * (vexRT[Ch3] + vexRT[Ch1]);
		motor[leftBack] =  ratio * (vexRT[Ch3] - vexRT[Ch1]);
		motor[rightFront] = ratio * (vexRT[Ch2] - vexRT[Ch1]);
		motor[rightBack] =  ratio * (vexRT[Ch2] + vexRT[Ch1]);

		//Lift
		motor[Motor5] = ratio * vexRT[Ch3Xmtr2];
		motor[Motor6] = ratio * vexRT[Ch3Xmtr2];
		motor[Motor8] = ratio * vexRT[Ch3Xmtr2];
		motor[Motor9] = ratio * vexRT[Ch3Xmtr2];

		motor[Motor7] = vexRT[Ch1Xmtr2];//Claw
		while (vexRT[Btn6UXmtr2]){
			lift(70, 120);
			wait1Msec(500);
			lift(70,0);
			crab(-70, 700);
			wait1Msec(500);
		}
	}
}
